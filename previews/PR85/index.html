<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · RemoteS.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/custom.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RemoteS.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Gallery</span><ul><li><a class="tocitem" href="gallery/Aqua_orbits/remotes_sat_tracks/">Aqua orbits</a></li><li><a class="tocitem" href="gallery/Aqua_sst/remotes_L2_SST/">Aqua SST</a></li><li><a class="tocitem" href="gallery/HLS/cloud-native-hls-data/">Cloud-Native HLS dat</a></li><li><a class="tocitem" href="gallery/L8cube_img/remotes_L8_cube_img/">Landsat 8 images</a></li><li><a class="tocitem" href="gallery/L8cube_ndvi/remotes_L8_NDVI/">Landsat 8 NDVI</a></li></ul></li><li class="is-active"><a class="tocitem" href>Index</a><ul class="internal"><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li><li><a class="tocitem" href="#Functions-1"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="RemoteS-1"><a class="docs-heading-anchor" href="#RemoteS-1">RemoteS</a><a class="docs-heading-anchor-permalink" href="#RemoteS-1" title="Permalink"></a></h1><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#RemoteS.classification_proba-Tuple{GMT.GItype, Any}"><code>RemoteS.classification_proba</code></a></li><li><a href="#RemoteS.classify-Tuple{GMT.GItype, Union{String, Vector{&lt;:GMT.GMTdataset}}}"><code>RemoteS.classify</code></a></li><li><a href="#RemoteS.classify-Tuple{GMT.GItype, Any}"><code>RemoteS.classify</code></a></li><li><a href="#RemoteS.clg-Tuple{Any, Any}"><code>RemoteS.clg</code></a></li><li><a href="#RemoteS.clip_orbits-Tuple{Any, Vector{&lt;:Real}}"><code>RemoteS.clip_orbits</code></a></li><li><a href="#RemoteS.clre-Tuple{Any, Any}"><code>RemoteS.clre</code></a></li><li><a href="#RemoteS.cutcube-Tuple{}"><code>RemoteS.cutcube</code></a></li><li><a href="#RemoteS.dn2radiance-Tuple{String}"><code>RemoteS.dn2radiance</code></a></li><li><a href="#RemoteS.dn2reflectance-Tuple{String}"><code>RemoteS.dn2reflectance</code></a></li><li><a href="#RemoteS.dn2temperature-Tuple{String}"><code>RemoteS.dn2temperature</code></a></li><li><a href="#RemoteS.evi-Tuple{Any, Any, Any}"><code>RemoteS.evi</code></a></li><li><a href="#RemoteS.evi2-Tuple{Any, Any}"><code>RemoteS.evi2</code></a></li><li><a href="#RemoteS.findscenes-Tuple{Real, Real}"><code>RemoteS.findscenes</code></a></li><li><a href="#RemoteS.gli-Tuple{GMT.GMTimage{UInt8, 3}}"><code>RemoteS.gli</code></a></li><li><a href="#RemoteS.gndvi-Tuple{Any, Any}"><code>RemoteS.gndvi</code></a></li><li><a href="#RemoteS.grid_at_sensor"><code>RemoteS.grid_at_sensor</code></a></li><li><a href="#RemoteS.mcari-Tuple{Any, Any, Any}"><code>RemoteS.mcari</code></a></li><li><a href="#RemoteS.mndwi-Tuple{Any, Any}"><code>RemoteS.mndwi</code></a></li><li><a href="#RemoteS.msavi-Tuple{Any, Any}"><code>RemoteS.msavi</code></a></li><li><a href="#RemoteS.mtci-Tuple{Any, Any, Any}"><code>RemoteS.mtci</code></a></li><li><a href="#RemoteS.nbri-Tuple{Any, Any}"><code>RemoteS.nbri</code></a></li><li><a href="#RemoteS.ndrei1-Tuple{Any, Any}"><code>RemoteS.ndrei1</code></a></li><li><a href="#RemoteS.ndrei2-Tuple{Any, Any}"><code>RemoteS.ndrei2</code></a></li><li><a href="#RemoteS.ndvi-Tuple{Any, Any}"><code>RemoteS.ndvi</code></a></li><li><a href="#RemoteS.ndwi-Tuple{Any, Any}"><code>RemoteS.ndwi</code></a></li><li><a href="#RemoteS.ndwi2-Tuple{Any, Any}"><code>RemoteS.ndwi2</code></a></li><li><a href="#RemoteS.read_mtl"><code>RemoteS.read_mtl</code></a></li><li><a href="#RemoteS.reflectance_surf-Tuple{String}"><code>RemoteS.reflectance_surf</code></a></li><li><a href="#RemoteS.reportbands-Tuple{Any, Int64}"><code>RemoteS.reportbands</code></a></li><li><a href="#RemoteS.sat_scenes-Tuple{Any, String}"><code>RemoteS.sat_scenes</code></a></li><li><a href="#RemoteS.sat_tracks-Tuple{}"><code>RemoteS.sat_tracks</code></a></li><li><a href="#RemoteS.satvi-Tuple{Any, Any, Any}"><code>RemoteS.satvi</code></a></li><li><a href="#RemoteS.savi-Tuple{Any, Any}"><code>RemoteS.savi</code></a></li><li><a href="#RemoteS.slavi-Tuple{Any, Any, Any}"><code>RemoteS.slavi</code></a></li><li><a href="#RemoteS.subcube-Tuple{String}"><code>RemoteS.subcube</code></a></li><li><a href="#RemoteS.tgi-Tuple{GMT.GMTimage{UInt8, 3}}"><code>RemoteS.tgi</code></a></li><li><a href="#RemoteS.train_raster-Tuple{GMT.GItype, Union{String, Vector{&lt;:GMT.GMTdataset}}}"><code>RemoteS.train_raster</code></a></li><li><a href="#RemoteS.truecolor-Tuple{Any, Any, Any}"><code>RemoteS.truecolor</code></a></li><li><a href="#RemoteS.vari-Tuple{GMT.GMTimage{UInt8, 3}}"><code>RemoteS.vari</code></a></li><li><a href="#RemoteS.RemoteS"><code>RemoteS.RemoteS</code></a></li></ul><h2 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RemoteS.classify-Tuple{GMT.GItype, Any}" href="#RemoteS.classify-Tuple{GMT.GItype, Any}"><code>RemoteS.classify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">I = classify(cube::GItype, model; class_names::Union{String, Vector{String}}=&quot;&quot;) -&gt; GMTimage</code></pre><ul><li><code>cube</code>: The cube wtih band data to classify.</li><li><code>model</code>: The trained model obtained from the <code>train_raster</code> function.</li><li><code>class_names</code>: A vector of strings with the class names to be used in the categorical colorbar or a  comma separated single with those class names. The number of class names must match the number used  when training the model with <code>train_raster</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/utils.jl#L780-L788">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.classify-Tuple{GMT.GItype, Union{String, Vector{&lt;:GMT.GMTdataset}}}" href="#RemoteS.classify-Tuple{GMT.GItype, Union{String, Vector{&lt;:GMT.GMTdataset}}}"><code>RemoteS.classify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">I = classify(cube::GItype, train::Union{Vector{&lt;:GMTdataset}, String}) -&gt; GMTimage</code></pre><ul><li><code>cube</code>: The cube wtih band data to classify.</li><li><code>train</code>: A vector of GMTdatasets or a file name of one containing the polygons used to train the model.  NOTE: The individual datasets MUST have associated an attribute called &quot;class&quot; containing the class name as a string.  This can be achieved for text data in the form of a GMT multi-segment file (one where segments are separated by the &#39;&gt;&#39;  symbol) if the multi-segment separator line contains the text <span>$Attrib(class=name)$</span></li></ul><p>Returns an image with the classification results where each class name was assigned a different integer number. That colorized image can plotted with <span>$viz(I, colorbar=true)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/utils.jl#L759-L770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.clg-Tuple{Any, Any}" href="#RemoteS.clg-Tuple{Any, Any}"><code>RemoteS.clg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CLG = clg(green, redEdge3; kw...)</code></pre><p>or</p><pre><code class="language-none">CLG = clg(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Green cholorphyl index. Wu et al 2012.</p><p>CLG = (redEdge3)/(green)-1 </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L56-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.clip_orbits-Tuple{Any, Vector{&lt;:Real}}" href="#RemoteS.clip_orbits-Tuple{Any, Vector{&lt;:Real}}"><code>RemoteS.clip_orbits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clip_orbits(track, BoundingBox::Vector{&lt;:Real})</code></pre><p>Clips the orbits that are contained inside a rectangular geographical region</p><ul><li><code>track</code>: A GMTdataset or a Mx2 matrix with the orbits [lon, lat] position. This is normally calculated   with the <code>sat_tracks</code> function.</li><li><code>BoundingBox</code>: A vector the region limits made up with [lon<em>min, lon</em>max, lat<em>min, lat</em>max]</li></ul><p>Returns a GMTdataset vector with the chunks of <code>tracks</code> that cross inside the <code>BoundingBox</code> region.</p><p>#Example Suppose <code>orb</code> holds orbits computed with sat_tracks() during 2 days, clip them inside the 20W-10E, 30N-45N window</p><pre><code class="language-none">D = clip_orbits(orb, [-20, 10, 30, 50]);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/sat_tracks.jl#L134-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.clre-Tuple{Any, Any}" href="#RemoteS.clre-Tuple{Any, Any}"><code>RemoteS.clre</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CLRE = clre(redEdge1, redEdge3; kw...)</code></pre><p>or</p><pre><code class="language-none">CLRE = clre(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>RedEdge cholorphyl index. Clevers and Gitelson 2013.</p><p>CLRE = (redEdge3)/(redEdge1)-1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L74-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.cutcube-Tuple{}" href="#RemoteS.cutcube-Tuple{}"><code>RemoteS.cutcube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cutcube(names=String[], bands=Int[], template=&quot;&quot;, region=nothing, extension=&quot;.TIF&quot;, description=String[], mtl=&quot;&quot;, sentinel2=0, save=&quot;&quot;)</code></pre><p>Cut a 3D cube out of a Landsat/Sentinel scene within a subregion <code>region</code> and a selection of bands.</p><ul><li><code>names</code>: (optional) A vector with the individual bands full file name</li><li><code>bands</code>: When <code>names</code> is not provided give a vector of integers corresponding to the choosen bands.          This works well for Landsat and most of Sentinel bands. However, in later case, there are also          bands that contain characters, for example band 8A. In this case <code>bands</code> should be a vector of          strings including the extension. <em>e.g.</em> [&quot;02.jp2&quot;, &quot;8A.jp2&quot;]</li><li><code>template</code>: Goes together with the <code>bands</code> option. They are both composed a template * band[n] to recreate          the full file name of each band.</li><li><code>region</code> Is the region to extract and must contain the extracting region limits as [W, E, S, N] or a          GMT style -R string (without the leading &quot;-R&quot;).</li><li><code>extension</code>: In case the <code>bands</code> is numeric but file extensions are not &quot;*.TIF&quot; (case insensitive),          use the extension passed by this option.</li><li><code>description</code>: A vector of strings (as many as bands) with a description for each band. If not provided and          the file is recognized as a Landasat 8, band description is added automatically, otherwise          we build one with the bands file names. This info will saved if data is written to a file.</li><li><code>mtl</code>:   If reading from Landsat and the MTL file is not automatically found (you get an error) use this          option to pass the full name of the MTL file.</li><li><code>sentinel2</code>: ESA is just unconsistent and names change with time and band numbers can have character (e.g. 8A)          hence we need help to recognize Sentinel files so the known description can be assigned.          Use <code>sentinel=10</code>, or <code>=20</code> or <code>=60</code> to indicate Sentinel files at those resolutions.</li><li><code>save</code>:  The file name where to save the output. If not provided, a GMTimage is returned.</li></ul><p>Return: <code>nothing</code> if the result is written in file or a GMTimage otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Cut a Landsat 8 scene for a small region (in UTM) and return a GMTimage with 3 bands in UInt16.
temp = &quot;C:\SIG_AnaliseDadosSatelite\SIG_ADS\DadosEx2\LC82040332015145LGN00\LC82040332015145LGN00_B&quot;;
cube = cutcube(bands=[2,3,4], template=temp, region=[479670,492720,4282230,4294500])

# The same example as above but save the data in a GeoTIFF disk file and use a string for `region`
cutcube(bands=[2,3,4], template=temp, region=&quot;479670/492720/4282230/4294500&quot;, save=&quot;landsat_cube.tif&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/utils.jl#L319-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.dn2radiance-Tuple{String}" href="#RemoteS.dn2radiance-Tuple{String}"><code>RemoteS.dn2radiance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R = dn2radiance(fname::String, [band::Int, bandname::String, mtl::String, save::String])</code></pre><p>Computes the radiance at TopOfAtmosphere of a Landsat 8 file</p><ul><li><code>fname</code>: The name of either a <span>$LANDSAT_PRODUCT_ID$</span> geotiff band, or the name of a cube file created with the <code>cutcube</code> function. In the first case, if the companion <span>$...MTL.txt$</span> file is not in the same directory as <code>fname</code> one can still pass it via the <code>mtl=path-to-MTL-file</code> option. In the second case it is mandatory to use one of the following two options.</li><li><code>band</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>band</code> is used we search for the band named &quot;Band N&quot;, where N = <code>band</code>.</li><li><code>bandname</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandname</code> string that will be matched against the cube&#39;s bands descriptions. We can use the <code>reportbands</code> function to see the bands description.</li><li><code>save</code>:  The file name where to save the output. If not provided, a GMTgrid is returned.</li></ul><p>Returns a Float32 GMTgrid</p><p><strong>Example:</strong></p><p>Compute the radiance TOA of Band 2 file.</p><pre><code class="language-none">R = dn2radiance(&quot;LC08_L1TP_204033_20210525_20210529_02_T1_B2.TIF&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/utils.jl#L636-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.dn2reflectance-Tuple{String}" href="#RemoteS.dn2reflectance-Tuple{String}"><code>RemoteS.dn2reflectance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R = dn2reflectance(fname::String, [band::Int, bandname::String, mtl::String, save::String])</code></pre><p>Computes the TopOfAtmosphere planetary reflectance of a Landsat8 file</p><ul><li><code>fname</code>: The name of either a <span>$LANDSAT_PRODUCT_ID$</span> geotiff band, or the name of a cube file created with the <code>cutcube</code> function. In the first case, if the companion <span>$...MTL.txt$</span> file is not in the same directory as <code>fname</code> one can still pass it via the <code>mtl=path-to-MTL-file</code> option. In the second case it is mandatory to use one of the following two options.</li><li><code>band</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>band</code> is used we search for the band named &quot;Band N&quot;, where N = <code>band</code>.</li><li><code>bandname</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandname</code> string that will be matched against the cube&#39;s bands descriptions. We can use the <code>reportbands</code> function to see the bands description.</li><li><code>save</code>:  The file name where to save the output. If not provided, a GMTgrid is returned.</li></ul><p>Returns a Float32 GMTgrid</p><p><strong>Example:</strong></p><p>Compute the reflectance TOA of Red Band stored in a <code>cube</code></p><pre><code class="language-none">R = dn2reflectance(cube, bandname=&quot;red&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/utils.jl#L654-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.dn2temperature-Tuple{String}" href="#RemoteS.dn2temperature-Tuple{String}"><code>RemoteS.dn2temperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R = dn2temperature(fname::String; band::Int=0, mtl::String=&quot;&quot;, save::String)</code></pre><p>Computes the brigthness temperature of Landasat8 termal band (10 or 11)</p><ul><li><code>fname</code>: The name of either a <span>$LANDSAT_PRODUCT_ID$</span> geotiff band, or the name of a cube file created with the <code>cutcube</code> function. In the first case, if the companion <span>$...MTL.txt$</span> file is not in the same directory as <code>fname</code> one can still pass it via the <code>mtl=path-to-MTL-file</code> option. In the second case it is mandatory to use one of the following two options.</li><li><code>band</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>band</code> is used we search for the band named &quot;Band N&quot;, where N = <code>band</code>.</li><li><code>bandname</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandname</code> string that will be matched against the cube&#39;s bands descriptions. We can use the <code>reportbands</code> function to see the bands description.</li><li><code>save</code>:  The file name where to save the output. If not provided, a GMTgrid is returned.</li></ul><p>Returns a Float32 GMTgrid</p><p><strong>Example:</strong></p><p>Compute the brightness temperature of Band 10 stored in a <code>cube</code></p><pre><code class="language-none">T = dn2temperature(cube, band=10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/utils.jl#L596-L609">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.evi-Tuple{Any, Any, Any}" href="#RemoteS.evi-Tuple{Any, Any, Any}"><code>RemoteS.evi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">EVI = evi(blue, red, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">EVI = evi(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Enhanced vegetation index. Huete et al 1990</p><p>EVI = G * ((nir - red) / (nir + C1 * red - C2 * blue + Levi)); C1, C2, G, Levi = 6.0, 7.5, 2.5, 1.</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The last form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band&#39;band[k]&#39;&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li></ul><p><strong>Kwargs</strong></p><ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li><li><code>order</code> | <code>bands_order</code> | <code>rgb</code>: For the <span>$GLI$</span>, <span>$TGI$</span> and <span>$VARI$</span> (RGB) indices, we allow to reorder the bands and change the expected RGB order. Pass in a string, or symbol, with the color order. For example, <code>order=:rbg</code></li></ul><pre><code class="language-none">will swap the green and blue components making the result index identify the _reds_ instead of the _greens_.
Not good for vegetation indices, but potentially useful for other purposes.</code></pre><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L92-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.evi2-Tuple{Any, Any}" href="#RemoteS.evi2-Tuple{Any, Any}"><code>RemoteS.evi2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">EVI2 = evi2(red, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">EVI2 = evi2(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Two-band Enhanced vegetation index. Jiang et al 2008</p><p>EVI2 = G * ((nir - red) / (nir + 2.4 * red ))</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The last form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band&#39;band[k]&#39;&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li></ul><p><strong>Kwargs</strong></p><ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li><li><code>order</code> | <code>bands_order</code> | <code>rgb</code>: For the <span>$GLI$</span>, <span>$TGI$</span> and <span>$VARI$</span> (RGB) indices, we allow to reorder the bands and change the expected RGB order. Pass in a string, or symbol, with the color order. For example, <code>order=:rbg</code></li></ul><pre><code class="language-none">will swap the green and blue components making the result index identify the _reds_ instead of the _greens_.
Not good for vegetation indices, but potentially useful for other purposes.</code></pre><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L114-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.findscenes-Tuple{Real, Real}" href="#RemoteS.findscenes-Tuple{Real, Real}"><code>RemoteS.findscenes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findscenes(lon::Real, lat::Real; kwargs...)</code></pre><p>Find the names of the scenes that cover the location point <code>lon</code>, <code>lat</code> in the period determined by the dates and satellite set via kwargs.</p><ul><li><code>day</code>: Search only on the day time part of the orbits.</li><li><code>night</code>: Search only on the night time part of the orbits.</li><li><code>oc</code>: For the AQUA or TERRA satellites pick only the chlorophyl content scenes.</li><li><code>sst</code>: For the AQUA or TERRA satellites pick only the Sae Surface Temperature content scenes.</li><li><code>sat</code>, <code>SAT</code> or <code>satellite</code>: Name of the satellite to use; choose from (string or symbols)  :TERRA, :AQUA</li><li><code>start</code>: A DateTime object or a string convertable to a DateTime with <code>DateTime(start)</code>  specifying the start of the looking period. If omited, current time in UTC will be used.</li><li><code>duration</code>: Length of time for which the scenes are searched. The duration is expected in days  and can be a negative number, meaning we&#39;ll look that span days from <code>start</code>.</li><li><code>stop</code>: As alternative to <code>duration</code> provide the end date for the serch. Same conditions as <code>start</code></li><li><code>tle</code> or <code>TLE</code>: a file name with the TLE data for a specific satellite and period. It can also be a two elements string vector with the first and second lines of the TLE file.</li></ul><p><strong>Returns</strong></p><p>A string vector with the scene names</p><p><strong>Example:</strong></p><p>Find the AQUA scenes with chlorophyl-a (oceancolor) that cover the point (-8, 36) in the two days before &quot;2021-09-07T17:00:00&quot; Note, this will be accurate for the month of September 2021. For other dates it needs an updated TLE.</p><pre><code class="language-none">tle1 = &quot;1 27424U 02022A   21245.83760660  .00000135  00000-0  39999-4 0  9997&quot;;
tle2 = &quot;2 27424  98.2123 186.0654 0002229  67.6025 313.3829 14.57107527 28342&quot;;
findscenes(-8,36, start=&quot;2021-09-07T17:00:00&quot;, sat=:aqua, day=true, duration=-2, oc=1, tle=[tle1, tle2])

2-element Vector{String}:
&quot;A2021251125500.L2_LAC_OC.nc&quot;
&quot;A2021252134000.L2_LAC_OC.nc&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/sat_tracks.jl#L171-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.gli-Tuple{GMT.GMTimage{UInt8, 3}}" href="#RemoteS.gli-Tuple{GMT.GMTimage{UInt8, 3}}"><code>RemoteS.gli</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GLI = gli(red, green, blue; kw...)</code></pre><p>or (here fname is a .png or .jpg file name)</p><pre><code class="language-none">GLI = gli(fname::String; kw...)</code></pre><p>or</p><pre><code class="language-none">GLI = gli(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Green Leaf Index. Louhaichi, M., Borman, M.M., Johnson, D.E., 2001. </p><p>GLI = (2green - red - blue) / (2green + red + blue)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The last form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band&#39;band[k]&#39;&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li></ul><p><strong>Kwargs</strong></p><ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li><li><code>order</code> | <code>bands_order</code> | <code>rgb</code>: For the <span>$GLI$</span>, <span>$TGI$</span> and <span>$VARI$</span> (RGB) indices, we allow to reorder the bands and change the expected RGB order. Pass in a string, or symbol, with the color order. For example, <code>order=:rbg</code></li></ul><pre><code class="language-none">will swap the green and blue components making the result index identify the _reds_ instead of the _greens_.
Not good for vegetation indices, but potentially useful for other purposes.</code></pre><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L154-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.gndvi-Tuple{Any, Any}" href="#RemoteS.gndvi-Tuple{Any, Any}"><code>RemoteS.gndvi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GNDVI = gndvi(green, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">GNDVI = gndvi(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>green Normalized diff vegetation index: more sensitive to cholorphyll than ndvi. Gitelson, A., and M. Merzlyak</p><p>GNDVI = (nir - green) / (nir + green)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The last form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band&#39;band[k]&#39;&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li></ul><p><strong>Kwargs</strong></p><ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li><li><code>order</code> | <code>bands_order</code> | <code>rgb</code>: For the <span>$GLI$</span>, <span>$TGI$</span> and <span>$VARI$</span> (RGB) indices, we allow to reorder the bands and change the expected RGB order. Pass in a string, or symbol, with the color order. For example, <code>order=:rbg</code></li></ul><pre><code class="language-none">will swap the green and blue components making the result index identify the _reds_ instead of the _greens_.
Not good for vegetation indices, but potentially useful for other purposes.</code></pre><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L134-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.grid_at_sensor" href="#RemoteS.grid_at_sensor"><code>RemoteS.grid_at_sensor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">G = grid_at_sensor(fname::String, sds_name::String=&quot;&quot;; V::Bool=false, kw...)</code></pre><p>Read one of those netCDF files that are not regular grids but have instead the coordinates in the LONGITUDE and LATITUDE arrays. MODIS L2 files are a good example of this. Data in theses files are not layed down on a regular grid and we must interpolate to get one. Normally the lon and lat arrays are called <span>$longitude$</span> and <span>$latitude$</span> and these it&#39;s what is seek for by default. But files exist that pretend to comply to CF but use other names. In this case, use the kwargs <code>xarray</code> &amp; <code>yarray</code> to pass in the variable names. For example: <code>xarray=&quot;XLONG&quot;</code>, <code>yarray=&quot;XLAT&quot;</code> The other fundamental info to pass in is the name of the array to be read/interpolated. We do that via the <code>sds_name</code> arg.</p><ul><li><p><code>band</code>: In simpler cases the variable to be interpolated lays down on a 2D array but it is also possible that it is stored in a 3D array. If that is the case, use the keyword &#39;band&#39; to select a band (ex: &#39;band=2&#39;) Bands are numbered from 1.</p></li><li><p><code>region</code> | <code>limits</code>, <code>inc</code> | <code>increment</code> | <code>spacing</code> and <code>search_radius</code>: The interpolation is done so far with <span>$nearneighbor$</span> Both the region (-R) and increment (-I) are estimated from data but they can be set with <code>region</code> and <code>inc</code> kwargs as well. One can also set the <span>$nearneighbor$</span> serach radius with option <code>search_radius</code>. The defaul is to set <code>search_radius</code> equal to two times the average increment.</p></li><li><p><code>quality</code>: For MODIS data we can select the quality flag to filter by data quality. By default the best quality (=0) is used, but one can select another with the <code>quality=val</code> kwarg. Positive &#39;val&#39; values select data of quality &lt;= quality, whilst negative &#39;val&#39; values select only data with quality &gt;= abs(val). This allows for example to extract only the cloud coverage.</p></li><li><p><code>t_srs</code> or <code>target_proj</code>: Some polar grids come with <span>$longitude$</span>, <span>$latitude$</span> (or just <span>$lon$</span>, <span>$lat$</span>) arrays in geographical coordinates. There must be an (obscure) reason for this but the practical result is messy because coordinate spacings are highly variable preventing any decent guess. In these cases it is useful to reproject the data before griding. For that purpose use the <code>t_srs</code> or <code>target_proj</code> option to tell the program to do a coordinate conversion before gridding. <code>t_srs</code> should then be a proj4 string with the destiny projection system.</p></li><li><p><code>nodata</code>: Sometimes datasets use other than NaN to represent nodata but they don&#39;t specify it in the netCDF attributes (<em>e.g.</em> the NSIDC products). This option allows to fix this (<em>i.e</em> <code>nodata=-9999</code>) Note that this is automatically set for the NSIDC products.</p></li><li><p><code>nointerp</code>: Means to not do any nearneighbor interpolation but needs that <code>region</code> has been set.</p></li><li><p><code>NSIDC_N</code> and <code>NSIDC_S</code>: Set the <code>s_srs</code>, <code>region</code>, <code>nointerp</code>, <code>nodata</code> appropriate to read the See Ice NSIDC https://nsidc.org/data/polar-stereo/ps_grids.html grids.</p></li><li><p><code>dataset</code> or <code>xyz</code>: If instead of calculating a grid (returned as a GMTgrid type) user wants the x,y,z data intself, use the keywords <code>dataset</code>, or <code>xyz</code> and the output will be in a GMTdataset (i.e. use <code>dataset=true</code>).</p></li></ul><p>To inquire just the list of available arrays use <code>list=true</code> or <code>gdalinfo=true</code> to get the full file info.</p><pre><code class="language-none">Examples:

G = grid_at_sensor(&quot;AQUA_MODIS.20020717T135006.L2.SST.nc&quot;, &quot;sst&quot;, V=true);

G = grid_at_sensor(&quot;TXx-narr-annual-timavg.nc&quot;, &quot;T2MAX&quot;, xarray=&quot;XLONG&quot;, yarray=&quot;XLAT&quot;, V=true);

G = grid_at_sensor(&quot;RDEFT4_20101021.nc&quot;, &quot;sea_ice_thickness&quot;, NSIDC_N=true);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/grid_at_sensor.jl#L1-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.mcari-Tuple{Any, Any, Any}" href="#RemoteS.mcari-Tuple{Any, Any, Any}"><code>RemoteS.mcari</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MCARI = mcari(green, red, redEdge1; kw...)</code></pre><p>or</p><pre><code class="language-none">MCARI = mcari(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Modified Chlorophyll Absorption ratio index. Daughtery et al. 2000</p><p>MCARI = (redEdge1 - red - 0.2 * (redEdge1 - green)) * (redEdge1 / red)</p><p>(Sentinel-2 Band 5 (VNIR), Band 4 (Red) and Band 3 (Green)).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L212-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.mndwi-Tuple{Any, Any}" href="#RemoteS.mndwi-Tuple{Any, Any}"><code>RemoteS.mndwi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MNDWI = mndwi(green, swir2; kw...)</code></pre><p>or</p><pre><code class="language-none">MNDWI = mndwi(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Modified Normalised Difference Water Index. Xu2006</p><p>MNDWI = (green-swir2) / (green+swir2)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The last form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band&#39;band[k]&#39;&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li></ul><p><strong>Kwargs</strong></p><ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li><li><code>order</code> | <code>bands_order</code> | <code>rgb</code>: For the <span>$GLI$</span>, <span>$TGI$</span> and <span>$VARI$</span> (RGB) indices, we allow to reorder the bands and change the expected RGB order. Pass in a string, or symbol, with the color order. For example, <code>order=:rbg</code></li></ul><pre><code class="language-none">will swap the green and blue components making the result index identify the _reds_ instead of the _greens_.
Not good for vegetation indices, but potentially useful for other purposes.</code></pre><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L178-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.msavi-Tuple{Any, Any}" href="#RemoteS.msavi-Tuple{Any, Any}"><code>RemoteS.msavi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MSAVI = msavi(red, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">MSAVI = msavi(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Modified soil adjusted vegetation index. Qi 1994</p><p>MSAVI = nir + 0.5 - (0.5 * sqrt(pow(2.0 * nir + 1.0, 2) - 8.0 * (nir - (2.0 * red))))</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The last form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band&#39;band[k]&#39;&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li></ul><p><strong>Kwargs</strong></p><ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li><li><code>order</code> | <code>bands_order</code> | <code>rgb</code>: For the <span>$GLI$</span>, <span>$TGI$</span> and <span>$VARI$</span> (RGB) indices, we allow to reorder the bands and change the expected RGB order. Pass in a string, or symbol, with the color order. For example, <code>order=:rbg</code></li></ul><pre><code class="language-none">will swap the green and blue components making the result index identify the _reds_ instead of the _greens_.
Not good for vegetation indices, but potentially useful for other purposes.</code></pre><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L232-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.mtci-Tuple{Any, Any, Any}" href="#RemoteS.mtci-Tuple{Any, Any, Any}"><code>RemoteS.mtci</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MTCI = mtci(red, redEdge1, redEdge2; kw...)</code></pre><p>Meris Terrestrial Chlorophyll Index. Clevers and Gitelson 2013, Dash and Curran 2004</p><p>MTCI = (redEdge2-redEdge1) / (redEdge1-red)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L198-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.nbri-Tuple{Any, Any}" href="#RemoteS.nbri-Tuple{Any, Any}"><code>RemoteS.nbri</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NBRI = nbri(nir, swir3; kw...)</code></pre><p>or</p><pre><code class="language-none">NBRI = nbri(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Normalised Burn Ratio Index. Garcia 1991</p><p>NBRI = (nir - swir2) / (nir + swir2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L252-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.ndrei1-Tuple{Any, Any}" href="#RemoteS.ndrei1-Tuple{Any, Any}"><code>RemoteS.ndrei1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NDREI1 = ndrei1(redEdge1, redEdge2; kw...)</code></pre><p>Normalized difference red edge index. Gitelson and Merzlyak 1994</p><p>NDREI1 = (redEdge2 - redEdge1) / (redEdge2 + redEdge1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L333-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.ndrei2-Tuple{Any, Any}" href="#RemoteS.ndrei2-Tuple{Any, Any}"><code>RemoteS.ndrei2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NDREI2 = ndrei2(redEdge1, redEdge3; kw...)</code></pre><p>or</p><pre><code class="language-none">NDREI2 = ndrei2(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Normalized difference red edge index 2. Barnes et al 2000</p><p>NDREI2 = (redEdge3 - redEdge1) / (redEdge3 + redEdge1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L346-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.ndvi-Tuple{Any, Any}" href="#RemoteS.ndvi-Tuple{Any, Any}"><code>RemoteS.ndvi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NDVI = ndvi(red, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">NDVI = ndvi(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Compute the NDVI vegetation index. Input can be either the bands file names, or GMTimage objects with the band&#39;s data.</p><p>NDVI = (nir - red) / (nir + red)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The last form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band&#39;band[k]&#39;&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li></ul><p><strong>Kwargs</strong></p><ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li><li><code>order</code> | <code>bands_order</code> | <code>rgb</code>: For the <span>$GLI$</span>, <span>$TGI$</span> and <span>$VARI$</span> (RGB) indices, we allow to reorder the bands and change the expected RGB order. Pass in a string, or symbol, with the color order. For example, <code>order=:rbg</code></li></ul><pre><code class="language-none">will swap the green and blue components making the result index identify the _reds_ instead of the _greens_.
Not good for vegetation indices, but potentially useful for other purposes.</code></pre><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L271-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.ndwi-Tuple{Any, Any}" href="#RemoteS.ndwi-Tuple{Any, Any}"><code>RemoteS.ndwi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NDWI = ndwi(green, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">NDWI = ndwi(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Normalized difference water index. McFeeters 1996. NDWI =&gt; (green - nir)/(green + nir)</p><p>NDWI = (green - nir)/(green + nir)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The last form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band&#39;band[k]&#39;&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li></ul><p><strong>Kwargs</strong></p><ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li><li><code>order</code> | <code>bands_order</code> | <code>rgb</code>: For the <span>$GLI$</span>, <span>$TGI$</span> and <span>$VARI$</span> (RGB) indices, we allow to reorder the bands and change the expected RGB order. Pass in a string, or symbol, with the color order. For example, <code>order=:rbg</code></li></ul><pre><code class="language-none">will swap the green and blue components making the result index identify the _reds_ instead of the _greens_.
Not good for vegetation indices, but potentially useful for other purposes.</code></pre><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L292-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.ndwi2-Tuple{Any, Any}" href="#RemoteS.ndwi2-Tuple{Any, Any}"><code>RemoteS.ndwi2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NDWI2 = ndwi2(nir, swir2; kw...)</code></pre><p>or</p><pre><code class="language-none">NDWI2 = ndwi2(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Normalized difference water index. Gao 1996, Chen 2005 (also known as Normalized Difference Moisture Index NDBI and LSWI)</p><p>NDWI2 = (nir - swir2)/(nir + swir2)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The last form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band&#39;band[k]&#39;&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li></ul><p><strong>Kwargs</strong></p><ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li><li><code>order</code> | <code>bands_order</code> | <code>rgb</code>: For the <span>$GLI$</span>, <span>$TGI$</span> and <span>$VARI$</span> (RGB) indices, we allow to reorder the bands and change the expected RGB order. Pass in a string, or symbol, with the color order. For example, <code>order=:rbg</code></li></ul><pre><code class="language-none">will swap the green and blue components making the result index identify the _reds_ instead of the _greens_.
Not good for vegetation indices, but potentially useful for other purposes.</code></pre><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L312-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.reflectance_surf-Tuple{String}" href="#RemoteS.reflectance_surf-Tuple{String}"><code>RemoteS.reflectance_surf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R = reflectance_surf(fname::String, [band::Int, bandname::String, mtl::String, save::String])</code></pre><p>Computes the radiance-at-surface of Landsat8 band using the COST model.</p><ul><li><code>fname</code>: The name of either a <span>$LANDSAT_PRODUCT_ID$</span> geotiff band, or the name of a cube file created with the <code>cutcube</code> function. In the first case, if the companion <span>$...MTL.txt$</span> file is not in the same directory as <code>fname</code> one can still pass it via the <code>mtl=path-to-MTL-file</code> option. In the second case it is mandatory to use one of the following two options.</li><li><code>band</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band 1 ...&quot; an so on the other bands. So when <code>band</code> is used we search for the band named &quot;Band N&quot;, where N = <code>band</code>.</li><li><code>bandname</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandname</code> string that will be matched against the cube&#39;s bands descriptions. We can use the <code>reportbands</code> function to see the bands description.</li><li><code>save</code>:  The file name where to save the output. If not provided, a GMTgrid is returned.</li></ul><p>Returns a Float32 GMTgrid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/utils.jl#L717-L723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.reportbands-Tuple{Any, Int64}" href="#RemoteS.reportbands-Tuple{Any, Int64}"><code>RemoteS.reportbands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reportbands(in; [layers=Int[]])</code></pre><p>or</p><pre><code class="language-none">reportbands(in, layer;)</code></pre><p>Report the Bands description of the <code>in</code> input argument. This can be a GMTimage, a GMTgrid or a file name (a String) of  a &#39;cube&#39; file. Normally one made with the <code>cutcube</code> function. When the use conditions of this function are not met, either a warning or an error message (if too deep to be caught as a warning) will be issued.</p><ul><li><code>layers</code>: When this optional parameter is used, report the description of the bands in the vector <code>layers</code></li><li><code>layer</code>: A scalar with a unique band number. Alternative form to <code>reportbands(in, layers=[layer])</code></li></ul><p>Returns a string vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/utils.jl#L290-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.sat_scenes-Tuple{Any, String}" href="#RemoteS.sat_scenes-Tuple{Any, String}"><code>RemoteS.sat_scenes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sat<em>scenes(track, sat</em>name::String)</p><p>Compute polygons delimiting AQUA and TERRA scenes.</p><ul><li><code>trac</code>: Is an orbit computed with <code>sat_tracks</code> at steps of 1 minute (crucial)</li><li><code>sat_name</code>: The satellite name. At this time only AQUA and TERRA are allowed.</li></ul><p>Returns a GMTdataset vector with the polygons and the scene names in the dataset <code>header</code> field.</p><p><strong>Example</strong></p><p>Imagine that <code>orb</code> was obtained with</p><p>orb = sat_tracks(tle=[tle1; tle2], start=DateTime(&quot;2021-09-02T13:30:00&quot;), 	stop=DateTime(&quot;2021-09-02T13:40:00&quot;), step=&quot;1m&quot;);</p><p>The scenes limits (two) are computed with:</p><pre><code class="language-none">Dscenes = sat_scenes(orb, &quot;AQUA&quot;);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/sat_tracks.jl#L80-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.sat_tracks-Tuple{}" href="#RemoteS.sat_tracks-Tuple{}"><code>RemoteS.sat_tracks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sat_tracks(; geocentric::Bool=false, tiles::Bool=false, position::Bool=false, kwargs...)</code></pre><p>Compute satellite tracks using the TLE, or Two Line Elements set, a data format that contains information about the orbit at a specific epoch of an Earth-orbiting object. It can also calculate polygons arround the scene extents of AQUA and TERRA satellites as well as create the scene names, which provides a mean to direct download that data.</p><ul><li><code>start</code>: A DateTime object or a string convertable to a DateTime with <code>DateTime(start)</code>  specifying the start of the orbit calculation. If omited, current time in UTC will be used.</li><li><code>duration</code>: Length of time for which the orbit is calculated. Accepts duration in days, hours,  minutes or seconds. The default is minutes (100 minutes). To use other units use a string with  the value appended with &#39;D&#39;, &#39;h&#39;, &#39;m&#39; or &#39;s&#39;. <em>e.g.</em> <code>duration=&quot;55m&quot;</code> to compute orbit 55 minutes from <code>start</code></li><li><code>step</code> or <code>inc</code> or <code>dt</code>: The time interval at which to compute locations along the orbit. The default  unit here is seconds (30 sec) but minutes can be used as well by appending &#39;m&#39;. <em>e.g.</em> <code>step=&quot;1m&quot;</code></li><li><code>stop</code>: As alternative to <code>duration</code> provide the end date for the orbit. Same conditions as <code>start</code></li><li><code>position</code>: Computes only first location at the <code>start</code> time. Boolean, use <code>position=true</code></li><li><code>geocentric</code>: Boolean to controls if output is <code>lon,lat,alt,time</code> (the default) or <code>ECEF</code> coordinates + time.</li><li><code>tle</code> or <code>TLE</code>: a file name with the TLE data for a specific satellite and period. It can also be a two elements string vector with the first and second lines of the TLE file.</li><li><code>tiles</code>: Compute the scene limits and file names for some satellites. Currently AQUA only.</li><li><code>sat</code>, <code>SAT</code> or <code>satellite</code>: Name of the satellite to use; choose from (string or symbols)  :TERRA, :AQUA. Use only with the <code>tiles</code> option.</li></ul><p><strong>Returns</strong></p><p>A GMTdataset with the orbit or the scene polygons</p><p><strong>Example:</strong></p><p>Compute ~one orbit of the AQUA satellite starting at current local time. Note, this will be accurate for the month of September 2021. For other dates it needs an updated TLE.</p><pre><code class="language-none">tle1 = &quot;1 27424U 02022A   21245.83760660  .00000135  00000-0  39999-4 0  9997&quot;;
tle2 = &quot;2 27424  98.2123 186.0654 0002229  67.6025 313.3829 14.57107527 28342&quot;;
orb = sat_tracks(tle=[tle1; tle2], duration=100);</code></pre><p>and the orbit track can be visualized with</p><pre><code class="language-none">imshow(orb,  proj=:Robinson, region=:global, coast=true)</code></pre><p>WARNING: This function depends on the SatelliteToolbox extension that is not loaded by default. Load it with:</p><ul><li><span>$using RemoteS, SatelliteToolboxTle, SatelliteToolboxPropagators, SatelliteToolboxTransformations$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/sat_tracks.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.satvi-Tuple{Any, Any, Any}" href="#RemoteS.satvi-Tuple{Any, Any, Any}"><code>RemoteS.satvi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SATVI = satvi(red, swir2, swir3; kw...)</code></pre><p>or</p><pre><code class="language-none">SATVI = satvi(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Soil adjusted total vegetation index. Marsett 2006</p><p>SATVI = ((swir1 - red) / (swir1 + red + L)) * (1.0 + L) - (swir2 / 2.0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L364-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.savi-Tuple{Any, Any}" href="#RemoteS.savi-Tuple{Any, Any}"><code>RemoteS.savi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SAVI = savi(red, nir; kw...)</code></pre><p>or</p><pre><code class="language-none">SAVI = savi(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Soil adjusted vegetation index. Huete 1988</p><p>SAVI = (nir - red) * (1.0 + L) / (nir + red + L)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The last form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band&#39;band[k]&#39;&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li></ul><p><strong>Kwargs</strong></p><ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li><li><code>order</code> | <code>bands_order</code> | <code>rgb</code>: For the <span>$GLI$</span>, <span>$TGI$</span> and <span>$VARI$</span> (RGB) indices, we allow to reorder the bands and change the expected RGB order. Pass in a string, or symbol, with the color order. For example, <code>order=:rbg</code></li></ul><pre><code class="language-none">will swap the green and blue components making the result index identify the _reds_ instead of the _greens_.
Not good for vegetation indices, but potentially useful for other purposes.</code></pre><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L382-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.slavi-Tuple{Any, Any, Any}" href="#RemoteS.slavi-Tuple{Any, Any, Any}"><code>RemoteS.slavi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SLAVI = slavi(red, nir, swir2; kw...)</code></pre><p>or</p><pre><code class="language-none">SLAVI = slavi(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Specific Leaf Area Vegetation Index. Lymburger 2000</p><p>SLAVI = nir / (red + swir2)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The last form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band&#39;band[k]&#39;&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li></ul><p><strong>Kwargs</strong></p><ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li><li><code>order</code> | <code>bands_order</code> | <code>rgb</code>: For the <span>$GLI$</span>, <span>$TGI$</span> and <span>$VARI$</span> (RGB) indices, we allow to reorder the bands and change the expected RGB order. Pass in a string, or symbol, with the color order. For example, <code>order=:rbg</code></li></ul><pre><code class="language-none">will swap the green and blue components making the result index identify the _reds_ instead of the _greens_.
Not good for vegetation indices, but potentially useful for other purposes.</code></pre><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L402-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.subcube-Tuple{String}" href="#RemoteS.subcube-Tuple{String}"><code>RemoteS.subcube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">subcube(cube::String; bands=Int[], bandnames=String[], layers=Int[])</code></pre><p>Extracts a subcube from <code>cube</code> with the layers in the <code>bands</code> vector, case in which we will search for bands named &quot;Band band[k]&quot;, or those whose names correspond (even partially and case insensitive) to the descriptions in <code>bandnames</code> string vector. This means that the options <code>bands</code> and <code>bandnames</code> can only be used in &#39;cubes&#39; with bands description. The <code>layers</code> option blindly extract the <code>cube</code> planes listed in the <code>layer</code> vector.</p><p>Returns a GMTimage</p><pre><code class="language-none">subcube(cube::Union{GMT.GMTimage{UInt16, 3}, AbstractArray{&lt;:AbstractFloat, 3}}; bands=Int[], bandnames=String[], layers=Int[])</code></pre><p>Does the same but from an already in memory cube. Returns a type equal to the input type. No views, a data copy.</p><p><strong>Example</strong></p><p>Extracts the Red, Green and Blue layers from a Landsat 8 cube created with <code>cutcube</code></p><pre><code class="language-none">Irgb = subcube(&quot;LC08__cube.tiff&quot;, bandnames = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/utils.jl#L179-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.tgi-Tuple{GMT.GMTimage{UInt8, 3}}" href="#RemoteS.tgi-Tuple{GMT.GMTimage{UInt8, 3}}"><code>RemoteS.tgi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TGI = tgi(red, green, blue; kw...)</code></pre><p>or (here fname is a .png or .jpg file name)</p><pre><code class="language-none">TGI = tgi(fname::String; kw...)</code></pre><p>or</p><pre><code class="language-none">TGI = tgi(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Triangular Greenness Index. Hunt et al. 2013</p><p>TGI = green - 0.39 * red - 0.61 * blue</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The last form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band&#39;band[k]&#39;&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li></ul><p><strong>Kwargs</strong></p><ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li><li><code>order</code> | <code>bands_order</code> | <code>rgb</code>: For the <span>$GLI$</span>, <span>$TGI$</span> and <span>$VARI$</span> (RGB) indices, we allow to reorder the bands and change the expected RGB order. Pass in a string, or symbol, with the color order. For example, <code>order=:rbg</code></li></ul><pre><code class="language-none">will swap the green and blue components making the result index identify the _reds_ instead of the _greens_.
Not good for vegetation indices, but potentially useful for other purposes.</code></pre><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L422-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.train_raster-Tuple{GMT.GItype, Union{String, Vector{&lt;:GMT.GMTdataset}}}" href="#RemoteS.train_raster-Tuple{GMT.GItype, Union{String, Vector{&lt;:GMT.GMTdataset}}}"><code>RemoteS.train_raster</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">model, classes = train_raster(cube::GItype, train::Union{Vector{&lt;:GMTdataset}, String}; np::Int=0, density=0.1)</code></pre><ul><li><code>cube</code>: The cube wtih band data to classify.</li><li><code>train</code>: A vector of GMTdatasets or a file name of one containing the polygons used to train the model.  NOTE: The individual datasets MUST have associated an attribute called &quot;class&quot; containing the class name as a string.  This can be achieved for text data in the form of a GMT multi-segment file (one where segments are separated by the &#39;&gt;&#39;  symbol) if the multi-segment separator line contains the text <span>$Attrib(class=name)$</span></li><li><code>np</code>: Number of points per polygon to be determined by <span>$randinpolygon$</span></li><li><code>density</code>: Alternative to <code>np</code>. See also the help of the <span>$randinpolygon$</span> function.</li></ul><p>Returns the trained model and the class names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/utils.jl#L831-L843">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.truecolor-Tuple{Any, Any, Any}" href="#RemoteS.truecolor-Tuple{Any, Any, Any}"><code>RemoteS.truecolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Irgb = truecolor(bndR, bndG, bndB)</code></pre><p>Take three Landsat8/Sentinel2 UINT16 GMTimages or the file names of those bands and compose an RGB true color image applying automatic histogram stretching.</p><p>Return an UInt8 RGB GMTimage</p><pre><code class="language-none">Irgb = truecolor(cube::GMTImage, bands::Vector{Int})</code></pre><p>Make an RGB composition of the 3 bands passed in the vector &#39;bands&#39; from the layers in the multi-layered GMTimage <code>cube</code></p><p>Return an auto-stretched UInt8 RGB GMTimage</p><pre><code class="language-none">Irgb = truecolor(cube::String, [bands::Vector{Int}], [bandnames::Vector{String}], [raw=false])</code></pre><p>Make an RGB composition of 3 bands from the <code>cube</code> file holding a UInt16 multi-layered array (often created with <code>cutcube</code>) The band selection can be made with <code>bands</code> vector, case in which we will search for bands named &quot;Band[k]&quot; or where the bands description contain the contents of <code>bandnames</code>. If none of <code>bands</code> or <code>bandnames</code> is used we search for a made up <code>bandnames=[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</code>.</p><p>Return an auto-stretched UInt8 RGB GMTimage OR a GMTimage{UInt16,3} if the <code>raw</code> option is set to <code>true</code>.</p><pre><code class="language-none">Irgb = truecolor(cube::GMTgrid, [bands|layers::Vector{Int}], [bandnames::Vector{String}], [type=UInt8])</code></pre><p>Make an RGB composition of 3 bands from the <code>cube</code> file holding a Float32 multi-layered array. The band selection can be made with <code>bands</code> vector, case in which we will search for bands named &quot;Band[k]&quot; or where the bands description contain the contents of <code>bandnames</code>. If none of <code>bands</code> or <code>bandnames</code> is used we search for a made up <code>bandnames=[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</code>.</p><p>By default we scale the bands to 0-255. Use <code>type=UInt16</code> to scale the bands to 0-65535`. Note that this will matter only for the guessing of the good limits to perform the histogram stretching.</p><p><strong>Example:</strong></p><p>Make an RGB composite from data in the cube file &quot;LC08__cube.tiff&quot;</p><pre><code class="language-julia">I = truecolor(&quot;LC08__cube.tiff&quot;);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/utils.jl#L52-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.vari-Tuple{GMT.GMTimage{UInt8, 3}}" href="#RemoteS.vari-Tuple{GMT.GMTimage{UInt8, 3}}"><code>RemoteS.vari</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">VARI = vari(red, green, blue; kw...)</code></pre><p>or (here fname is a .png or .jpg file name)</p><pre><code class="language-none">VARI = vari(fname::String; kw...)</code></pre><p>or</p><pre><code class="language-none">VARI = vari(cube::Union{String, GMTgrid}; [bands=Int[], bandnames=String[], layers=Int[]], kwargs...)</code></pre><p>Visible Atmospherically Resistant Index. Gitelson, A.A., Kaufman, Y.J., Stark, R., Rundquist, D., 2002</p><p>VARI = (green - red) / (green + red - blue)</p><ul><li>The first form accepts inputs as matrices, or file names of the data bands.</li><li>The last form is more versatile but also more complex to describe.<ul><li><code>cube</code>: Is the file name of a &#39;cube&#39;, a multi-layered file normally created with the <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> function.  If this file was created with band descriptions one can use the <code>bands</code> or the <code>bandnames</code> options.</li><li><code>bands</code>: <em>cubes</em> created with <a href="#RemoteS.cutcube-Tuple{}"><code>cutcube</code></a> assign descriptions starting with &quot;Band1 ...&quot; an so on the other bands. So when <code>bands</code> is used we search for bands named &quot;Band&#39;band[k]&#39;&quot;, where band[k] loops over all elements of the <code>bands</code> vector. WARNING: the elements order in the vector must be sorted in increasing wavelength numbers, <em>i.e.</em> like the example for the first form.</li><li><code>layers</code>: Use this option when you are certain of the bands order in the cube or the it doesn&#39;t have a bands description. The selection will be made with cube[:,:,layer[1]], etc... WARNING: same warn as above.</li><li><code>bandnames</code>: When we know the common designation of a band, for example &quot;Green&quot;, or any part of a band description, for example &quot;NIR&quot;, we can use that info to create a <code>bandnames</code> string vector that will be matched against the cube&#39;s bands descriptions.</li></ul></li></ul><p><strong>Kwargs</strong></p><ul><li><code>threshold</code>: When a threshold is provided we return a GMTgrid where <code>vals[ij] &lt; threshold = NaN</code></li><li><code>classes</code>: is a vector with up to 3 elements (class separators) and we return a  UInt8 GMTimage with the indices categorized into vals[ij] &gt; classes[1] = 1; vals[ij] &gt; classes[2] = 2; vals[ij] &gt; classes[3] = 3 and 0 otherwise.</li><li><code>mask</code>: Used together with <code>threshold</code> outputs a UInt8 GMTimage mask with <code>vals[ij] &gt;= threshold = 255</code> and 0 otherwise  If <code>mask=-1</code> (or any other negative number) we compute instead a mask where <code>vals[ij] &lt; threshold = 255</code> and 0 otherwise</li><li><code>save</code>: Use <code>save=&quot;file_name.ext&quot;</code> to save the result in a disk file. File format is picked from file extension.</li><li><code>order</code> | <code>bands_order</code> | <code>rgb</code>: For the <span>$GLI$</span>, <span>$TGI$</span> and <span>$VARI$</span> (RGB) indices, we allow to reorder the bands and change the expected RGB order. Pass in a string, or symbol, with the color order. For example, <code>order=:rbg</code></li></ul><pre><code class="language-none">will swap the green and blue components making the result index identify the _reds_ instead of the _greens_.
Not good for vegetation indices, but potentially useful for other purposes.</code></pre><p>If none of <code>bands</code>, <code>layers</code> or <code>bandnames</code> is provided, we use the default band names shown in the first form.</p><p>See also https://www.indexdatabase.de/ for a list of indices and the appropriate band names per sensor.</p><p>Returns either a Float32 GMTgrid or a UInt8 GMTimage if the <code>mask</code> or <code>classes</code> options are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/spectral_indices.jl#L446-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.RemoteS" href="#RemoteS.RemoteS"><code>RemoteS.RemoteS</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Package to perform operations with satellite data. Easy to use in computing true color images with automatic contrast stretch, many spectral indices and processing of MODIS L2 files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/RemoteS.jl#L32-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.classification_proba-Tuple{GMT.GItype, Any}" href="#RemoteS.classification_proba-Tuple{GMT.GItype, Any}"><code>RemoteS.classification_proba</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">I = classification_proba(cube::GItype, model; class_number=1) -&gt; GMTimage</code></pre><p>Returns an image with the assigned probabilities when classifying the class number <code>class_number</code></p><ul><li><code>cube</code>: The cube wtih band data to classify</li><li><code>model</code>: is the model obtained from the <code>train_raster</code> function</li><li><code>class_number</code>: is the class number to be classified</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/utils.jl#L808-L816">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RemoteS.read_mtl" href="#RemoteS.read_mtl"><code>RemoteS.read_mtl</code></a> — <span class="docstring-category">Function</span></header><section><div><p>read<em>mtl(band</em>name::String, mtl::String=&quot;&quot;; get_full=false)</p><p>Use the <code>band_name</code> of a Landsat8 band to find the MTL file with the scene parameters at which that band belongs and read the params needed to compute Brightness temperature, radiance at top of atmosphere, etc. If the MTL file does not lieve next to the band file, send its name via the <code>mtl</code> argument.</p><p>The <code>get_full</code> option makes this function return a tring with contents of the MTL file or <code>nothing</code> if the MTL file is not found.</p><p><strong>Returns a tuple with:</strong></p><p>(band=band, rad<em>mul=rad</em>mul, rad<em>add=rad</em>add, rad<em>max=rad</em>max, reflect<em>mul=reflect</em>mul, reflect<em>add=reflect</em>add, reflect<em>max=reflect</em>max, sun<em>azim=sun</em>azim, sun<em>elev=sun</em>elev, sun<em>dis=sun</em>azim, K1=K1, K2=K2)</p><p>or a string with MTL contents (or nothing if MTL file is not found)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenericMappingTools/RemoteS.jl/blob/a36e34d59d8c05b3e7114e06f25877676a5e1c89/src/utils.jl#L453-L468">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="gallery/L8cube_ndvi/remotes_L8_NDVI/">« Landsat 8 NDVI</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 23 April 2025 11:53">Wednesday 23 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
